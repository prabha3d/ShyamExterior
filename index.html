<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js GLB Color GUI with Reset</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lil-gui@0.18/dist/lil-gui.min.css">

  <style>
    .lil-gui {
      --width: 300px;
      --name-width: 120px;
      font-size: 15px;
      --padding: 10px;
      --background-color: rgba(20, 20, 20, 0.95);
      --widget-color: #08f;
      --text-color: #eee;
      border-radius: 10px;
    }
  </style>

  
</head>
<body>
  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.160.1';
    import { OrbitControls } from 'https://esm.sh/three@0.160.1/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://esm.sh/three@0.160.1/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'https://esm.sh/three@0.160.1/examples/jsm/loaders/DRACOLoader.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm';
    import { EffectComposer } from 'https://esm.sh/three@0.160.1/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://esm.sh/three@0.160.1/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://esm.sh/three@0.160.1/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { SSAOPass } from 'https://esm.sh/three@0.160.1/examples/jsm/postprocessing/SSAOPass.js';

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xdddddd);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(6, 4, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.VSMShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // Postprocessing
    // const composer = new EffectComposer(renderer);
    // composer.addPass(new RenderPass(scene, camera));
    // composer.addPass(new SSAOPass(scene, camera, window.innerWidth, window.innerHeight));
    // composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.1, 0.4, 0.85));

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 4, -5);
    controls.enableDamping = true;
    controls.update();

    // Lighting
    const ambient = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
    scene.add(ambient);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
    directionalLight.position.set(5, 10, 7.5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.set(1028, 1028);
    directionalLight.shadow.bias = -0.0005;
    directionalLight.shadow.normalBias = 0.005;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    directionalLight.shadow.camera.left = -10;
    directionalLight.shadow.camera.right = 10;
    directionalLight.shadow.camera.top = 10;
    directionalLight.shadow.camera.bottom = -10;
    scene.add(directionalLight);

    const fillLight = new THREE.DirectionalLight(0xffffff, 1.0);
    fillLight.position.set(-5, 10, 7.5);
    scene.add(fillLight);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(50, 50);
    const groundMat = new THREE.ShadowMaterial({ opacity: 0.07 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Init lil-gui
    const gui = new GUI({ width: 300 });
    const colorFolder = gui.addFolder("Colors");
    colorFolder.open();

    // Track materials and colors
    const materialTracker = {};
    const originalColors = {};


    // Load model
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
    dracoLoader.setDecoderConfig({ type: 'js' });

    const loader = new GLTFLoader();
    loader.setDRACOLoader(dracoLoader);

    loader.load('Shyam.glb', (gltf) => {
      gltf.scene.traverse((node) => {
        if (node.isMesh) {
          node.castShadow = true;
          node.receiveShadow = true;

          const materials = Array.isArray(node.material) ? node.material : [node.material];

          materials.forEach((mat) => {
            if (!mat || !mat.name) return;

            if (["Color1", "Color2", "DarkGrey"].includes(mat.name) && !materialTracker[mat.name]) {
              const hex = `#${mat.color.getHexString()}`;
              originalColors[mat.name] = hex;

              const colorObj = { color: hex };

              colorFolder
                .addColor(colorObj, 'color')
                .name(mat.name)
                .onChange(value => mat.color.set(value));

              materialTracker[mat.name] = {
                material: mat,
                colorObj,
              };
            }
          });
        }
      });

      // Reset button
      colorFolder.add({ reset: () => {
        for (const name in materialTracker) {
          const { material, colorObj } = materialTracker[name];
          const original = originalColors[name];
          if (original) {
            colorObj.color = original;
            material.color.set(original);
          }
        }
        gui.updateDisplay();
      }}, 'reset').name("↺ Reset Colors");

      // Reset View Button
      const viewReset = {
        resetView: () => {
          camera.position.set(6, 4, 10);         // Original camera position
          controls.target.set(0, 4, -5);         // Original orbit target
          controls.update();
        }
      };
      gui.add(viewReset, 'resetView').name("↺ Reset View");


      scene.add(gltf.scene);
    }, undefined, (err) => {
      console.error("Model load error:", err);
    });

    // Animate
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      // composer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
