<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js GLB Color GUI with Reset</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lil-gui@0.18/dist/lil-gui.min.css">
  <link rel="icon" href="data:,">
  <style>
    .lil-gui {
      --width: 300px;
      ---name-width: 120px;
      --font-size: 15px;
      --padding: 10px;
      background-color: rgba(0, 0, 0, 0.308);
      --widget-color: #08f;
      --text-color: #eee;
      border-radius: 10px;
    }

    #resetViewBtn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      padding: 10px 16px;
      background-color: #222;
      color: #fff;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      opacity: 0.8;
      transition: all 0.2s ease;
    }

    #resetViewBtn:hover {
      opacity: 1;
      background-color: #000;
    }
  </style>
</head>
<body>

  <button id="resetViewBtn">↺ Reset View</button>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.160.1';
    import { OrbitControls } from 'https://esm.sh/three@0.160.1/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://esm.sh/three@0.160.1/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'https://esm.sh/three@0.160.1/examples/jsm/loaders/DRACOLoader.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm';
    import gsap from 'https://esm.sh/gsap';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xdddddd);

    // Cameras
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(6, 4, 10);
    const mainCamera = camera;

    const altCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    altCamera.position.set(0, 15, 0);
    altCamera.lookAt(0, 0, 0);

    let usingAltCamera = false;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.VSMShadowMap;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 4, -5);
    controls.enableDamping = true;
    controls.minDistance = 5;
    controls.maxDistance = 30;
    controls.minAzimuthAngle = -Math.PI / 12;
    controls.maxAzimuthAngle = Math.PI / 2;
    controls.minPolarAngle = Math.PI / 2.5;
    controls.maxPolarAngle = Math.PI / 1.75;
    controls.update();

    // Lighting
    const ambient = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
    scene.add(ambient);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
    directionalLight.position.set(5, 10, 7.5);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.set(1028, 1028);
    directionalLight.shadow.bias = -0.0005;
    directionalLight.shadow.normalBias = 0.005;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 50;
    directionalLight.shadow.camera.left = -10;
    directionalLight.shadow.camera.right = 10;
    directionalLight.shadow.camera.top = 10;
    directionalLight.shadow.camera.bottom = -10;
    scene.add(directionalLight);

    const fillLight = new THREE.DirectionalLight(0xffffff, 1.0);
    fillLight.position.set(-5, 10, 7.5);
    scene.add(fillLight);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(50, 50);
    const groundMat = new THREE.ShadowMaterial({ opacity: 0.07 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // GUI
    const gui = new GUI({ width: 300 });
    const colorFolder = gui.addFolder("Colors");
    colorFolder.open();

    const materialTracker = {};
    const originalColors = {};

    // Load GLB
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
    dracoLoader.setDecoderConfig({ type: 'js' });

    const loader = new GLTFLoader();
    loader.setDRACOLoader(dracoLoader);

    loader.load('Shyam.glb', (gltf) => {
      gltf.scene.traverse((node) => {
        if (node.isMesh) {
          node.castShadow = true;
          node.receiveShadow = true;

          const materials = Array.isArray(node.material) ? node.material : [node.material];

          materials.forEach((mat) => {
            if (!mat || !mat.name) return;

            if (["Color1", "Color2", "DarkGrey"].includes(mat.name) && !materialTracker[mat.name]) {
              const hex = `#${mat.color.getHexString()}`;
              originalColors[mat.name] = hex;

              const colorObj = { color: hex };

              colorFolder
                .addColor(colorObj, 'color')
                .name(mat.name)
                .onChange(value => mat.color.set(value));

              materialTracker[mat.name] = {
                material: mat,
                colorObj,
              };
            }
          });
        }
      });

      colorFolder.add({ reset: () => {
        for (const name in materialTracker) {
          const { material, colorObj } = materialTracker[name];
          const original = originalColors[name];
          if (original) {
            colorObj.color = original;
            material.color.set(original);
          }
        }
      }}, 'reset').name("↺ Reset Colors");

      scene.add(gltf.scene);
    }, undefined, (err) => {
      console.error("Model load error:", err);
    });

    // Hotspot
    const hotspotMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.5
    });

    const hotspot = new THREE.Mesh(
      new THREE.SphereGeometry(0.1, 16, 16),
      hotspotMaterial
    );
    hotspot.position.set(2, 1, -2);
    scene.add(hotspot);

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    window.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(hotspot);

      if (intersects.length > 0) {
        usingAltCamera = !usingAltCamera;
        const targetCam = usingAltCamera ? altCamera : mainCamera;

        // Animate camera position
        gsap.to(camera.position, {
          duration: 1.5,
          x: targetCam.position.x,
          y: targetCam.position.y,
          z: targetCam.position.z,
          ease: "power2.inOut",
          onUpdate: () => controls.update()
        });

        // Animate target
        const newTarget = usingAltCamera ? new THREE.Vector3(0, 0, 0) : new THREE.Vector3(0, 4, -5);
        const tempTarget = controls.target.clone();

        gsap.to(tempTarget, {
          duration: 1.5,
          x: newTarget.x,
          y: newTarget.y,
          z: newTarget.z,
          ease: "power2.inOut",
          onUpdate: () => {
            controls.target.copy(tempTarget);
            controls.update();
          }
        });
      }
    });

    // Reset view
    document.getElementById("resetViewBtn").addEventListener("click", () => {
      usingAltCamera = false;
      gsap.to(camera.position, {
        duration: 1.5,
        x: 6, y: 4, z: 10,
        ease: "power2.inOut"
      });
      const resetTarget = new THREE.Vector3(0, 4, -5);
      const tempTarget = controls.target.clone();

      gsap.to(tempTarget, {
        duration: 1.5,
        x: resetTarget.x,
        y: resetTarget.y,
        z: resetTarget.z,
        ease: "power2.inOut",
        onUpdate: () => {
          controls.target.copy(tempTarget);
          controls.update();
        }
      });
    });

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
